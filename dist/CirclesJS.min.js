(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Circles"] = factory();
	else
		root["Circles"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/CirclesJS.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/CirclesJS.js":
/*!**************************!*\
  !*** ./src/CirclesJS.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Circles; });
/* harmony import */ var _helpers_SVGHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/SVGHelper */ "./src/helpers/SVGHelper.js");
/* harmony import */ var _helpers_defaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/defaults */ "./src/helpers/defaults.js");
/* harmony import */ var _helpers_Validator__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./helpers/Validator */ "./src/helpers/Validator.js");
/* harmony import */ var _helpers_Geometrie__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./helpers/Geometrie */ "./src/helpers/Geometrie.js");
/* harmony import */ var _helpers_Animation__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./helpers/Animation */ "./src/helpers/Animation.js");
function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }







var Circles =
/*#__PURE__*/
function () {
  function Circles(conf) {
    _classCallCheck(this, Circles);

    this.config = conf; // VERIFYING CIRCLE CONFIGURAITON

    Object(_helpers_Validator__WEBPACK_IMPORTED_MODULE_2__["exist"])(['el', 'radius', 'value'], _objectSpread({
      el: conf.el
    }, conf.circle)); // SETTING DEFAULTS CONFIGURATION

    this.circle = Object(_helpers_defaults__WEBPACK_IMPORTED_MODULE_1__["setDefaultCofnig"])(['stroke_width', 'stroke', 'stroke_linecap', 'fill'], conf.circle);

    if (typeof conf.middleText !== 'undefined') {
      this.middleText = Object(_helpers_defaults__WEBPACK_IMPORTED_MODULE_1__["setDefaultCofnig"])(['font_size', 'font_weight', 'color', 'font_family'], conf.middleText);
    }

    if (_typeof(conf.fillRest) === 'object') {
      this.fillRest = _objectSpread({}, this.circle, {}, conf.fillRest);
      typeof this.circle.max_value === 'undefined' ? this.fillRest.value = 100 : this.fillRest.value = this.circle.max_value;
    }

    this.el = conf.el;
    this.middle = Object(_helpers_Geometrie__WEBPACK_IMPORTED_MODULE_3__["getMiddleCoord"])(conf.el);
    this.isDrawed = false;
  }

  _createClass(Circles, [{
    key: "draw",
    value: function draw() {
      this.isDrawed = true;
      var fillRestPath, text;
      var circlePath = Object(_helpers_SVGHelper__WEBPACK_IMPORTED_MODULE_0__["createCircle"])(_objectSpread({}, this.circle, {}, this.middle));

      if (typeof this.fillRest !== 'undefined') {
        fillRestPath = Object(_helpers_SVGHelper__WEBPACK_IMPORTED_MODULE_0__["createCircle"])(_objectSpread({}, this.fillRest, {}, this.middle));
        this.el.appendChild(fillRestPath);
      }

      if (typeof this.middleText !== 'undefined') {
        text = Object(_helpers_SVGHelper__WEBPACK_IMPORTED_MODULE_0__["createText"])(_objectSpread({}, this.middleText, {}, this.middle), this.circle.value);
        this.el.appendChild(text);
      }

      this.el.appendChild(circlePath);
      this.elContent = {
        circle: circlePath,
        restCircle: fillRestPath,
        middleText: text
      };
    }
  }, {
    key: "animate",
    value: function animate() {
      var duration = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 500;
      var to = this.circle.value;
      this.circle.value = 0;
      this.draw();
      var currentTime = new Date();
      window.requestAnimationFrame(_helpers_Animation__WEBPACK_IMPORTED_MODULE_4__["fillCircleAnimation"].bind(this, +currentTime, duration, this.circle.value, to));
    }
  }]);

  return Circles;
}();



/***/ }),

/***/ "./src/helpers/Animation.js":
/*!**********************************!*\
  !*** ./src/helpers/Animation.js ***!
  \**********************************/
/*! exports provided: fillCircleAnimation */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "fillCircleAnimation", function() { return fillCircleAnimation; });
/* harmony import */ var _Maths__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Maths */ "./src/helpers/Maths.js");
/* harmony import */ var _SVGHelper__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SVGHelper */ "./src/helpers/SVGHelper.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




function linearAnimation(duration, from, to, time) {
  return (time * ((to - from) / duration) + from).toFixed(2);
}

function fillCircleAnimation(time, duration, from, to) {
  var currentTime = +new Date();

  if (currentTime <= time + duration) {
    var angle = Object(_Maths__WEBPACK_IMPORTED_MODULE_0__["valueToAngle"])(this.circle.value, this.circle.max_angle, this.circle.max_value); // GETTING d ATTRIBUTE AND CHANGE IT

    var dAttribute = Object(_SVGHelper__WEBPACK_IMPORTED_MODULE_1__["getCirclePath"])(angle, _objectSpread({}, this.circle, {}, this.middle));
    this.elContent.circle.setAttribute('d', dAttribute); // ANIMATE VALUE JUST WHEN MIDDLE VALUE ISN'T A TEXT

    if (typeof this.middleText !== 'undefined' && typeof this.middleText.value_type !== 'undefined') {
      this.elContent.middleText.textContent = Object(_SVGHelper__WEBPACK_IMPORTED_MODULE_1__["getTextValue"])(this.circle.value, this.middleText.value_type);
    }

    this.circle.value = linearAnimation(duration, from, to, currentTime - time);
    window.requestAnimationFrame(fillCircleAnimation.bind(this, time, duration, from, to));
  }
}

/***/ }),

/***/ "./src/helpers/Geometrie.js":
/*!**********************************!*\
  !*** ./src/helpers/Geometrie.js ***!
  \**********************************/
/*! exports provided: degToRad, getCordFromAngle, getComputedRadius, getMiddleCoord */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degToRad", function() { return degToRad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCordFromAngle", function() { return getCordFromAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getComputedRadius", function() { return getComputedRadius; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getMiddleCoord", function() { return getMiddleCoord; });
/**
 * function return to convert degree angle to a radian angle
 * @param {number} deg the degree to convert
 */
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
/**
 * @function to get a cartesian coordination from polar coordination
 * @param {object} middleCord coordination of center of the circle
 * @param {Number} circleRadius radius of the circle
 * @param {Number} angle radian angle of the polar coordination
 */

function getCordFromAngle(middleCord, circleRadius, angle) {
  var x = middleCord.x + circleRadius * Math.cos(angle);
  var y = middleCord.y + circleRadius * Math.sin(angle);
  return {
    x: x,
    y: y
  };
}
/**
 * @param {int} strokeWidth stroke width of arc
 * @param {int} circleRadius radius of the circle
 * @param {int} margin margin to add
 */

function getComputedRadius(strokeWidth, circleRadius) {
  var margin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return circleRadius - margin - strokeWidth / 2;
}
/**
 * @function getMiddleCoord function to get middle of circle using svg size
 * @param {SVGElement} el main svg element to get middle coord
 */

function getMiddleCoord(el) {
  var size = el.getBoundingClientRect();
  return {
    x: size.width / 2,
    y: size.height / 2
  };
}

/***/ }),

/***/ "./src/helpers/Maths.js":
/*!******************************!*\
  !*** ./src/helpers/Maths.js ***!
  \******************************/
/*! exports provided: valueToAngle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueToAngle", function() { return valueToAngle; });
/**
 * function to convert value to an angle in circle
 * @param {int} value value to convert to an angle
 * @param {int} maxAngle maximum arc of circle in angle default value 360 degree (hole circle)
 * @param {int} maxValue maximume value in the arc
 * @returns {int}
 */
function valueToAngle(value) {
  var maxAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 360;
  var maxValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
  return value * maxAngle / maxValue;
}

/***/ }),

/***/ "./src/helpers/SVGHelper.js":
/*!**********************************!*\
  !*** ./src/helpers/SVGHelper.js ***!
  \**********************************/
/*! exports provided: getCirclePath, getTextValue, createText, createCircle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCirclePath", function() { return getCirclePath; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getTextValue", function() { return getTextValue; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createText", function() { return createText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCircle", function() { return createCircle; });
/* harmony import */ var _Geometrie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometrie */ "./src/helpers/Geometrie.js");
/* harmony import */ var _Maths__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Maths */ "./src/helpers/Maths.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaults */ "./src/helpers/defaults.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }




/**
 * CONSTANTS
 */

var PATH_SVGELEMENT = document.createElementNS('http://www.w3.org/2000/svg', 'path');
var TEXT_SVGELEMENT = document.createElementNS('http://www.w3.org/2000/svg', 'text');
/**
 * FUNCTIONS
 */

function createStyle(keys, config) {
  var str = "";
  keys.forEach(function (key) {
    str += "".concat(key.replace('_', '-'), ":").concat(config[key], ";");
  });
  return str;
}
/**
 * @function setCircleAttr function to set circle style
 * @param {SVGGElement} svgElement SVG element to setAttributes
 * @param {Object} config contain circle configuration
 */


function setCircleAttr(svgElement, config) {
  var style = createStyle(['stroke_width', 'stroke', 'stroke_linecap', 'fill'], config);
  svgElement.setAttribute('style', style);

  if (typeof config["class"] !== 'undefined') {
    svgElement.setAttribute('class', config["class"]);
  }
}
/**
 * @function getCirclePath function return circle path to append to svg element
 * @param {int} angle the angle of circle to draw in degree
 * @param {Object} config containt circle configuration
 */


function getCirclePath(angle, config) {
  var middleCoord = {
    x: config.x,
    y: config.y
  };
  var computedRaduis = Object(_Geometrie__WEBPACK_IMPORTED_MODULE_0__["getComputedRadius"])(config.stroke_width, config.radius);
  var startAngle = typeof config.start_angle === 'number' ? _defaults__WEBPACK_IMPORTED_MODULE_2__["Defaults"].START_ANGLE.top_middle + Object(_Geometrie__WEBPACK_IMPORTED_MODULE_0__["degToRad"])(config.start_angle) : _defaults__WEBPACK_IMPORTED_MODULE_2__["Defaults"].START_ANGLE.top_middle;
  var startCoord = Object(_Geometrie__WEBPACK_IMPORTED_MODULE_0__["getCordFromAngle"])(middleCoord, computedRaduis, startAngle);
  var endCoord = Object(_Geometrie__WEBPACK_IMPORTED_MODULE_0__["getCordFromAngle"])(middleCoord, computedRaduis, startAngle + Object(_Geometrie__WEBPACK_IMPORTED_MODULE_0__["degToRad"])(angle)); // SETTING PATH INFORMATIONS

  if (angle < 180) {
    return ['M', startCoord.x, startCoord.y, 'a', computedRaduis, computedRaduis, '0', '0', '1', endCoord.x - startCoord.x, endCoord.y - startCoord.y].join(' ');
  } else {
    var half = Object(_Geometrie__WEBPACK_IMPORTED_MODULE_0__["getCordFromAngle"])(middleCoord, computedRaduis, startAngle + Math.PI);
    return ['M', startCoord.x, startCoord.y, 'a', computedRaduis, computedRaduis, '0', '0', '1', half.x - startCoord.x, half.y - startCoord.y, 'a', computedRaduis, computedRaduis, '0', '0', '1', endCoord.x - half.x, endCoord.y - half.y].join(' ');
  }
}
/**
 * @function getTextValue function return value by used type in circle
 * @param {int} value value to write
 * @param {string} type value type
 * @returns {string} value to write
 */

function getTextValue(value, type) {
  switch (type) {
    case _defaults__WEBPACK_IMPORTED_MODULE_2__["Defaults"].PERCENTAGE_VALUE_TYPE:
      return value + '%';

    case _defaults__WEBPACK_IMPORTED_MODULE_2__["Defaults"].NUMBER_VALUE_TYPE:
      return value;
  }
}
/**
 * @function createText function return text elment to append in svg element
 * @param {Object} config configuration of text
 * @return {SVGElement}
 */

function createText(config) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var textSVGElement = TEXT_SVGELEMENT.cloneNode();
  var style = createStyle(['font_family', 'font_size', 'font_weight', 'color'], _objectSpread({}, config, {
    font_size: "".concat(config.font_size, "px")
  }));
  textSVGElement.setAttribute('text-anchor', 'middle');
  textSVGElement.setAttribute('x', config.x);
  textSVGElement.setAttribute('y', config.y + config.font_size / 4);
  textSVGElement.setAttribute('style', style);

  if (typeof config["class"] !== 'undefined') {
    textSVGElement.setAttribute('class', config["class"]);
  }

  if (typeof config.text === 'string') {
    textSVGElement.textContent = config.text;
  } else if (typeof config.value_type === 'string') {
    textSVGElement.textContent = getTextValue(value, config.value_type);
  }

  return textSVGElement;
}
/**
 * @function create_circle function return an SVGElement containe the circle path
 * @param {Object} config containe circle configuration
 * @returns {SVGElement} svg group contain the circle
 */

function createCircle() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var angle = Object(_Maths__WEBPACK_IMPORTED_MODULE_1__["valueToAngle"])(config.value, config.max_angle, config.max_value);
  var path = PATH_SVGELEMENT.cloneNode(false);
  path.setAttribute('d', getCirclePath(angle, config));
  setCircleAttr(path, config);
  return path;
}

/***/ }),

/***/ "./src/helpers/Validator.js":
/*!**********************************!*\
  !*** ./src/helpers/Validator.js ***!
  \**********************************/
/*! exports provided: exist */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "exist", function() { return exist; });
/**
 * @function exist function to verify existance of a key in configuration object
 * @param {Array} keys element to be checked in config object
 * @param {Object} config containe configuration
 */
function exist(keys, config) {
  keys.forEach(function (element) {
    if (typeof config[element] === 'undefined') {
      throw new Error("Configuration Error ".concat(element, " attribute undefined"));
    }
  });
}

/***/ }),

/***/ "./src/helpers/defaults.js":
/*!*********************************!*\
  !*** ./src/helpers/defaults.js ***!
  \*********************************/
/*! exports provided: Defaults, setDefaultCofnig */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Defaults", function() { return Defaults; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "setDefaultCofnig", function() { return setDefaultCofnig; });
var Defaults = {
  /* VALUES TYPES */
  PERCENTAGE_VALUE_TYPE: 'percentage',
  NUMBER_VALUE_TYPE: 'number',
  TEXT_VALUE_TYPE: 'text',

  /* CIRCLE STYLE */
  STROKE: 'black',
  STROKE_WIDTH: 1,
  STROKE_LINECAP: 'round',
  START_ANGLE: {
    top_middle: 3 / 2 * Math.PI
  },
  FILL: 'none',

  /* FONTS */
  FONT_SIZE: 16,
  FONT_WEIGHT: 'regular',
  COLOR: 'black'
};
function setDefaultCofnig(keys) {
  var config = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : {};
  keys.forEach(function (element) {
    if (typeof config[element] === 'undefined') {
      config[element] = Defaults[element.toUpperCase()];
    }
  });
  return config;
}

/***/ })

/******/ })["default"];
});
//# sourceMappingURL=CirclesJS.min.js.map