(function webpackUniversalModuleDefinition(root, factory) {
	if(typeof exports === 'object' && typeof module === 'object')
		module.exports = factory();
	else if(typeof define === 'function' && define.amd)
		define([], factory);
	else if(typeof exports === 'object')
		exports["Circles"] = factory();
	else
		root["Circles"] = factory();
})(this, function() {
return /******/ (function(modules) { // webpackBootstrap
/******/ 	// The module cache
/******/ 	var installedModules = {};
/******/
/******/ 	// The require function
/******/ 	function __webpack_require__(moduleId) {
/******/
/******/ 		// Check if module is in cache
/******/ 		if(installedModules[moduleId]) {
/******/ 			return installedModules[moduleId].exports;
/******/ 		}
/******/ 		// Create a new module (and put it into the cache)
/******/ 		var module = installedModules[moduleId] = {
/******/ 			i: moduleId,
/******/ 			l: false,
/******/ 			exports: {}
/******/ 		};
/******/
/******/ 		// Execute the module function
/******/ 		modules[moduleId].call(module.exports, module, module.exports, __webpack_require__);
/******/
/******/ 		// Flag the module as loaded
/******/ 		module.l = true;
/******/
/******/ 		// Return the exports of the module
/******/ 		return module.exports;
/******/ 	}
/******/
/******/
/******/ 	// expose the modules object (__webpack_modules__)
/******/ 	__webpack_require__.m = modules;
/******/
/******/ 	// expose the module cache
/******/ 	__webpack_require__.c = installedModules;
/******/
/******/ 	// define getter function for harmony exports
/******/ 	__webpack_require__.d = function(exports, name, getter) {
/******/ 		if(!__webpack_require__.o(exports, name)) {
/******/ 			Object.defineProperty(exports, name, { enumerable: true, get: getter });
/******/ 		}
/******/ 	};
/******/
/******/ 	// define __esModule on exports
/******/ 	__webpack_require__.r = function(exports) {
/******/ 		if(typeof Symbol !== 'undefined' && Symbol.toStringTag) {
/******/ 			Object.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });
/******/ 		}
/******/ 		Object.defineProperty(exports, '__esModule', { value: true });
/******/ 	};
/******/
/******/ 	// create a fake namespace object
/******/ 	// mode & 1: value is a module id, require it
/******/ 	// mode & 2: merge all properties of value into the ns
/******/ 	// mode & 4: return value when already ns object
/******/ 	// mode & 8|1: behave like require
/******/ 	__webpack_require__.t = function(value, mode) {
/******/ 		if(mode & 1) value = __webpack_require__(value);
/******/ 		if(mode & 8) return value;
/******/ 		if((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;
/******/ 		var ns = Object.create(null);
/******/ 		__webpack_require__.r(ns);
/******/ 		Object.defineProperty(ns, 'default', { enumerable: true, value: value });
/******/ 		if(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));
/******/ 		return ns;
/******/ 	};
/******/
/******/ 	// getDefaultExport function for compatibility with non-harmony modules
/******/ 	__webpack_require__.n = function(module) {
/******/ 		var getter = module && module.__esModule ?
/******/ 			function getDefault() { return module['default']; } :
/******/ 			function getModuleExports() { return module; };
/******/ 		__webpack_require__.d(getter, 'a', getter);
/******/ 		return getter;
/******/ 	};
/******/
/******/ 	// Object.prototype.hasOwnProperty.call
/******/ 	__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };
/******/
/******/ 	// __webpack_public_path__
/******/ 	__webpack_require__.p = "";
/******/
/******/
/******/ 	// Load entry module and return exports
/******/ 	return __webpack_require__(__webpack_require__.s = "./src/CirclesJS.js");
/******/ })
/************************************************************************/
/******/ ({

/***/ "./src/CirclesJS.js":
/*!**************************!*\
  !*** ./src/CirclesJS.js ***!
  \**************************/
/*! exports provided: default */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "default", function() { return Circles; });
/* harmony import */ var _helpers_SVGHelper__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./helpers/SVGHelper */ "./src/helpers/SVGHelper.js");
/* harmony import */ var _helpers_defaults__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./helpers/defaults */ "./src/helpers/defaults.js");
function ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(source, true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(source).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }




var Circles =
/*#__PURE__*/
function () {
  function Circles(conf) {
    _classCallCheck(this, Circles);

    this.config = conf; // VERIFYING CIRCLE CONFIGURAITON

    if (typeof conf.el === 'undefined') {
      throw new Error('Svg element not defined in configuration with \'el\' attribute');
    }

    if (typeof conf.circle.radius === 'undefined') {
      throw new Error('Circle radius not defined. define it with \'radius\' attribute');
    }

    if (typeof conf.circle.value === 'undefined') {
      throw new Error('Value to draw is undefined use the attribute \'value\' to define it');
    }

    if (typeof conf.middleText.text !== 'undefined' && typeof conf.middleText.valueType !== 'undefined') {
      throw new Error('You set both attributes \'text\' and \'valueType\'');
    } // SETTING DEFAULTS CONFIGURATION


    if (typeof conf.circle.strokeWidth === 'undefined') {
      this.config.circle.strokeWidth = _helpers_defaults__WEBPACK_IMPORTED_MODULE_1__["Defaults"].STROKE_WIDTH;
    }

    if (typeof conf.circle.color === 'undefined') {
      this.config.circle.color = _helpers_defaults__WEBPACK_IMPORTED_MODULE_1__["Defaults"].STROKE_COLOR;
    }

    if (typeof conf.circle.linecap === 'undefined') {
      this.config.circle.linecap = _helpers_defaults__WEBPACK_IMPORTED_MODULE_1__["Defaults"].LINE_CAP;
    }

    if (typeof conf.middleText.fontSize === 'undefined') {
      this.config.middleText.fontSize = _helpers_defaults__WEBPACK_IMPORTED_MODULE_1__["Defaults"].FONTS.font_size;
    }

    if (typeof conf.middleText.fontWeight === 'undefined') {
      this.config.middleText.fontWeight = _helpers_defaults__WEBPACK_IMPORTED_MODULE_1__["Defaults"].FONTS.font_weight;
    }

    if (_typeof(conf.fillRest) === 'object') {
      this.config.fillRest = _objectSpread({}, this.config.circle, {}, this.config.fillRest);
      typeof this.config.circle.maxValue === 'undefined' ? this.config.fillRest.value = 100 : this.config.fillRest.value = this.config.circle.maxValue;
    }

    this.el = conf.el;
    var size = this.el.getBoundingClientRect();
    this.config.dims = {};
    this.config.dims.width = size.width;
    this.config.dims.height = size.height;
  }

  _createClass(Circles, [{
    key: "draw",
    value: function draw() {
      this.config.middleText.width = this.config.circle.width;
      this.config.middleText.height = this.config.circle.height;
      var svgGroup = Object(_helpers_SVGHelper__WEBPACK_IMPORTED_MODULE_0__["createCircle"])(_objectSpread({}, this.config.circle, {}, this.config.dims));
      var text = Object(_helpers_SVGHelper__WEBPACK_IMPORTED_MODULE_0__["createText"])(_objectSpread({}, this.config.middleText, {}, this.config.dims), this.config.circle.value);

      if (typeof this.config.fillRest !== 'undefined') {
        var fillRestPath = Object(_helpers_SVGHelper__WEBPACK_IMPORTED_MODULE_0__["createCircle"])(_objectSpread({}, this.config.fillRest, {}, this.config.dims));
        console.log(fillRestPath);
        this.el.appendChild(fillRestPath);
      }

      this.el.appendChild(svgGroup);
      this.el.appendChild(text);
    }
  }]);

  return Circles;
}();



/***/ }),

/***/ "./src/helpers/Geometrie.js":
/*!**********************************!*\
  !*** ./src/helpers/Geometrie.js ***!
  \**********************************/
/*! exports provided: degToRad, getCordFromAngle, getComputedRadius */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "degToRad", function() { return degToRad; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getCordFromAngle", function() { return getCordFromAngle; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "getComputedRadius", function() { return getComputedRadius; });
/**
 * function return to convert degree angle to a radian angle
 * @param {number} deg the degree to convert
 */
function degToRad(deg) {
  return deg * (Math.PI / 180);
}
/**
 * @function to get a cartesian coordination from polar coordination
 * @param {object} middleCord coordination of center of the circle
 * @param {Number} circleRadius radius of the circle
 * @param {Number} angle radian angle of the polar coordination
 */

function getCordFromAngle(middleCord, circleRadius, angle) {
  var x = middleCord.x + circleRadius * Math.cos(angle);
  var y = middleCord.y + circleRadius * Math.sin(angle);
  return {
    x: x,
    y: y
  };
}
/**
 * @param {int} strokeWidth stroke width of arc
 * @param {int} circleRadius radius of the circle
 * @param {int} margin margin to add
 */

function getComputedRadius(strokeWidth, circleRadius) {
  var margin = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;
  return circleRadius - margin - strokeWidth / 2;
}

/***/ }),

/***/ "./src/helpers/Maths.js":
/*!******************************!*\
  !*** ./src/helpers/Maths.js ***!
  \******************************/
/*! exports provided: valueToAngle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "valueToAngle", function() { return valueToAngle; });
/**
 * function to convert value to an angle in circle
 * @param {int} value value to convert to an angle
 * @param {int} maxAngle maximum arc of circle in angle default value 360 degree (hole circle)
 * @param {int} maxValue maximume value in the arc
 * @returns {int}
 */
function valueToAngle(value) {
  var maxAngle = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 360;
  var maxValue = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 100;
  return value * maxAngle / maxValue;
}

/***/ }),

/***/ "./src/helpers/SVGHelper.js":
/*!**********************************!*\
  !*** ./src/helpers/SVGHelper.js ***!
  \**********************************/
/*! exports provided: GROUP_SVGELEMENT, PATH_SVGELEMENT, TEXT_SVGELEMENT, createText, createCircle */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "GROUP_SVGELEMENT", function() { return GROUP_SVGELEMENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "PATH_SVGELEMENT", function() { return PATH_SVGELEMENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "TEXT_SVGELEMENT", function() { return TEXT_SVGELEMENT; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createText", function() { return createText; });
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "createCircle", function() { return createCircle; });
/* harmony import */ var _Geometrie__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./Geometrie */ "./src/helpers/Geometrie.js");
/* harmony import */ var _Maths__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./Maths */ "./src/helpers/Maths.js");
/* harmony import */ var _defaults__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./defaults */ "./src/helpers/defaults.js");



/**
 * CONSTANTS
 */

var GROUP_SVGELEMENT = document.createElementNS('http://www.w3.org/2000/svg', 'g');
var PATH_SVGELEMENT = document.createElementNS('http://www.w3.org/2000/svg', 'path');
var TEXT_SVGELEMENT = document.createElementNS('http://www.w3.org/2000/svg', 'text');
/**
 * FUNCTIONS
 */

/**
 * @function setCircleAttr function to set circle style
 * @param {SVGGElement} svgElement SVG element to setAttributes
 * @param {Object} config contain circle configuration
 */

function setCircleAttr(svgElement, config) {
  svgElement.setAttribute('stroke-width', config.strokeWidth);
  svgElement.setAttribute('stroke', config.color);
  svgElement.setAttribute('stroke-linecap', config.linecap);
  svgElement.setAttribute('fill', 'none');

  if (typeof config.Class !== 'undefined') {
    svgElement.setAttribute('class', config.Class);
  }
}
/**
 * @function getCirclePath function return circle path to append to svg element
 * @param {int} angle the angle of circle to draw in degree
 * @param {Object} config containt circle configuration
 */


function getCirclePath(angle, config) {
  var path = PATH_SVGELEMENT.cloneNode(false);
  var middleCoord = {
    x: config.width / 2,
    y: config.height / 2
  };
  var computedRaduis = Object(_Geometrie__WEBPACK_IMPORTED_MODULE_0__["getComputedRadius"])(config.strokeWidth, config.radius);
  var startAngle = typeof config.startAngle === 'number' ? Object(_Geometrie__WEBPACK_IMPORTED_MODULE_0__["degToRad"])(config.startAngle) : _defaults__WEBPACK_IMPORTED_MODULE_2__["Defaults"].START_ANGLE.top_middle;
  var startCoord = Object(_Geometrie__WEBPACK_IMPORTED_MODULE_0__["getCordFromAngle"])(middleCoord, computedRaduis, startAngle);
  var endCoord = Object(_Geometrie__WEBPACK_IMPORTED_MODULE_0__["getCordFromAngle"])(middleCoord, computedRaduis, startAngle + Object(_Geometrie__WEBPACK_IMPORTED_MODULE_0__["degToRad"])(angle));

  if (angle < 180) {
    path.setAttribute('d', "M".concat(startCoord.x, ",").concat(startCoord.y, "\n                            a").concat(computedRaduis, ",").concat(computedRaduis, " 0 0 1 ").concat(endCoord.x - startCoord.x, ", ").concat(endCoord.y - startCoord.y));
  } else {
    var half = Object(_Geometrie__WEBPACK_IMPORTED_MODULE_0__["getCordFromAngle"])(middleCoord, computedRaduis, startAngle + Math.PI);
    path.setAttribute('d', "M".concat(startCoord.x, ",").concat(startCoord.y, "\n                            a").concat(computedRaduis, ",").concat(computedRaduis, " 0 0 1 ").concat(half.x - startCoord.x, ", ").concat(half.y - startCoord.y, "\n                            a").concat(computedRaduis, ",").concat(computedRaduis, " 0 0 1 ").concat(endCoord.x - half.x, ", ").concat(endCoord.y - half.y));
  }

  return path;
}
/**
 * @function getTextValue function return value by used type in circle
 * @param {int} value value to write
 * @param {string} type value type
 * @returns {string} value to write
 */


function getTextValue(value, type) {
  switch (type) {
    case _defaults__WEBPACK_IMPORTED_MODULE_2__["Defaults"].PERCENTAGE_VALUE_TYPE:
      return value + '%';

    case _defaults__WEBPACK_IMPORTED_MODULE_2__["Defaults"].NUMBER_VALUE_TYPE:
      return value;
  }
}
/**
 * @function createText function return text elment to append in svg element
 * @param {Object} config configuration of text
 * @return {SVGElement}
 */


function createText(config) {
  var value = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;
  var textSVGElement = TEXT_SVGELEMENT.cloneNode();
  textSVGElement.setAttribute('text-anchor', 'middle');
  textSVGElement.setAttribute('x', config.width / 2);
  textSVGElement.setAttribute('y', config.height / 2 + config.fontSize / 4);
  textSVGElement.setAttribute('style', "font-family: ".concat(config.fontFamily, ";font-size:").concat(config.fontSize, "px;font-weight:").concat(config.fontWeight, ";fill:").concat(config.color, ";"));

  if (typeof config.Class !== 'undefined') {
    textSVGElement.setAttribute('class', config.Class);
  }

  if (typeof config.text === 'string') {
    textSVGElement.textContent = config.text;
  }

  if (typeof config.valueType === 'string') {
    textSVGElement.textContent = getTextValue(value, config.valueType);
  }

  return textSVGElement;
}
/**
 * @function create_circle function return an SVGElement containe the circle path
 * @param {Object} config containe circle configuration
 * @returns {SVGElement} svg group contain the circle
 */

function createCircle() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};
  var angle = Object(_Maths__WEBPACK_IMPORTED_MODULE_1__["valueToAngle"])(config.value, config.maxAngle, config.maxValue);
  var path = getCirclePath(angle, config);
  setCircleAttr(path, config);
  return path;
}

/***/ }),

/***/ "./src/helpers/defaults.js":
/*!*********************************!*\
  !*** ./src/helpers/defaults.js ***!
  \*********************************/
/*! exports provided: Defaults */
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
__webpack_require__.r(__webpack_exports__);
/* harmony export (binding) */ __webpack_require__.d(__webpack_exports__, "Defaults", function() { return Defaults; });
var Defaults = {
  /* VALUES TYPES */
  PERCENTAGE_VALUE_TYPE: 'percentage',
  NUMBER_VALUE_TYPE: 'number',
  TEXT_VALUE_TYPE: 'text',

  /* CIRCLE STYLE */
  STROKE_COLOR: 'black',
  STROKE_WIDTH: 1,
  LINE_CAP: 'round',
  START_ANGLE: {
    top_middle: 3 / 2 * Math.PI,
    left_middle: Math.PI,
    bottom_middle: Math.PI / 2,
    right_middle: 0
  },

  /* FONTS */
  FONTS: {
    font_size: 16,
    font_family: 'Arial sans-serif',
    font_weight: 'regular'
  }
};

/***/ })

/******/ })["default"];
});
//# sourceMappingURL=CirclesJS.min.js.map